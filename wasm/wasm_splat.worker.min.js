import t,{process_splats_from_buffer as s,append_data_from_buffer as e,process_splats_from_geometry as r,process_splats_from_spz as o,sort_splats as u,compute_bounds as n,unregister_positions as l}from"./wasm_splat.min.js";let a=!1,f=null,c={};function _(t){return{outCS:new Float32Array(new ArrayBuffer(4*t*4)),outRC:new Uint32Array(new ArrayBuffer(4*t*4))}}self.onmessage=async i=>{const{id:d,fn:p,args:m}=i.data;try{let i;if("__init_wasm__"===p)return a||(await t(),a=!0),void postMessage({id:d,result:!0});if(await async function(){return!!a||(f||(f=t().then(()=>(a=!0,!0)).catch(t=>{throw a=!1,f=null,t})),f)}(),"process_splats_from_buffer"===p){const[t,e,r]=m,o=new Uint8Array(e),{outCS:u,outRC:n}=_(r),l=s(o,r,u,n);c[t]={bufferId:l},i={meshId:t,out_cs:u,out_rc:n}}else if("append_data_from_buffer"===p){let[t,s,r]=m;const{bufferId:o}=c[t];let u=new Uint8Array(s);const{outCS:n,outRC:l}=_(r);e(o,u,r,n,l),i={out_cs:n,out_rc:l},s=null,u=null}else if("process_splats_from_geometry"===p){let[t,s,e,o,u,n]=m;const{outCS:l,outRC:a}=_(n),f=r(s,e,o,u,n,l,a);c[t]={bufferId:f},i={meshId:t,out_cs:l,out_rc:a},s=null,e=null}else if("process_splats_from_spz"===p){let[t,s,e,r,u,n,l]=m;const{outCS:a,outRC:f}=_(l),d=o(s,e,r,u,n,l,a,f);c[t]={bufferId:d},i={meshId:t,out_cs:a,out_rc:f}}else if("sort_splats"===p){const[t,s,e,r]=m,{bufferId:o}=c[t];i={meshId:t,data:u(o,s,e,r)}}else if("compute_bounds"===p){const[t]=m,{bufferId:s}=c[t];i={meshId:t,data:n(s)}}else if("unregister_positions"===p){const[t]=m,{bufferId:s}=c[t];l(s),i=!0}i instanceof Uint32Array?(postMessage({id:d,result:i},[i.buffer]),i=null):i&&i.data?(postMessage({id:d,result:i},[i.data.buffer]),i.data=null,i=null):i&&i.out_cs&&i.out_rc?(postMessage({id:d,result:i},[i.out_cs.buffer,i.out_rc.buffer]),i.out_cs=null,i.out_rc=null,i=null):postMessage({id:d,result:i})}catch(t){console.error(t),postMessage({id:d,error:t?.message||String(t)})}};