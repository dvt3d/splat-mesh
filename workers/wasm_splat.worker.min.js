import t,{process_splats_from_buffer as s,append_data_from_buffer as e,process_splats_from_geometry as u,process_splats_from_spz as r,sort_splats as o,compute_bounds as l,unregister_positions as n}from"./wasm_splat.min.js";let a=!1,f=null,c={};function _(t){return{outCS:new Float32Array(new ArrayBuffer(4*t*4)),outRC:new Uint32Array(new ArrayBuffer(4*t*4))}}self.onmessage=async i=>{const{id:d,fn:p,args:m}=i.data;try{let i;if("__init_wasm__"===p)return a||(await t(),a=!0),void postMessage({id:d,result:!0});if(await async function(){return!!a||(f||(f=t().then(()=>(a=!0,!0)).catch(t=>{throw a=!1,f=null,t})),f)}(),"process_splats_from_buffer"===p){const[t,e,u]=m,r=new Uint8Array(e),{outCS:o,outRC:l}=_(u),n=s(r,u,o,l);c[t]={bufferId:n},i={meshId:t,out_cs:o,out_rc:l}}else if("append_data_from_buffer"===p){let[t,s,u]=m;const{bufferId:r}=c[t];let o=new Uint8Array(s);const{outCS:l,outRC:n}=_(u);e(r,o,u,l,n),i={out_cs:l,out_rc:n},s=null,o=null}else if("process_splats_from_geometry"===p){let[t,s,e,r,o,l]=m;const{outCS:n,outRC:a}=_(l),f=u(s,e,r,o,l,n,a);c[t]={bufferId:f},i={meshId:t,out_cs:n,out_rc:a},s=null,e=null,r=null,o=null}else if("process_splats_from_spz"===p){let[t,s,e,u,o,l,n]=m;const{outCS:a,outRC:f}=_(n),d=r(s,e,u,o,l,n,a,f);c[t]={bufferId:d},i={meshId:t,out_cs:a,out_rc:f},s=null,e=null,u=null,o=null,l=null}else if("sort_splats"===p){const[t,s,e,u]=m,{bufferId:r}=c[t];i={meshId:t,data:o(r,s,e,u)}}else if("compute_bounds"===p){const[t]=m,{bufferId:s}=c[t];i={meshId:t,data:l(s)}}else if("unregister_positions"===p){const[t]=m,{bufferId:s}=c[t];n(s),i=!0}i instanceof Uint32Array?(postMessage({id:d,result:i},[i.buffer]),i=null):i&&i.data?(postMessage({id:d,result:i},[i.data.buffer]),i.data=null,i=null):i&&i.out_cs&&i.out_rc?(postMessage({id:d,result:i},[i.out_cs.buffer,i.out_rc.buffer]),i.out_cs=null,i.out_rc=null,i=null):postMessage({id:d,result:i})}catch(t){console.error(t),postMessage({id:d,error:t?.message||String(t)})}};